// This file is auto-generated by @hey-api/openapi-ts

export type AdvisoryDetails = AdvisoryHead &
  (null | SourceDocument) & {
    /**
     * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_score: number | null;
    average_severity: null | Severity;
    /**
     * Vulnerabilities addressed within this advisory.
     */
    vulnerabilities: Array<AdvisoryVulnerabilitySummary>;
  };

export type AdvisoryHead = {
  /**
   * The identifier of the advisory, as provided by the document.
   */
  document_id: string;
  /**
   * The identifier of the advisory, as assigned by the issuing organization.
   */
  identifier: string;
  issuer: null | OrganizationSummary;
  /**
   * Informational labels attached by the system or users to this advisory.
   */
  labels: Labels;
  /**
   * The date (in RFC3339 format) of when the advisory was last modified, if any.
   */
  modified?: string | null;
  /**
   * The date (in RFC3339 format) of when the advisory was published, if any.
   */
  published: string | null;
  /**
   * The title of the advisory as assigned by the issuing organization.
   */
  title: string | null;
  /**
   * The opaque UUID of the advisory.
   */
  uuid: string;
  /**
   * The date (in RFC3339 format) of when the advisory was withdrawn, if any.
   */
  withdrawn: string | null;
};

export type AdvisorySummary = AdvisoryHead &
  (null | SourceDocument) & {
    /**
     * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_score: number | null;
    /**
     * Average (arithmetic mean) severity of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_severity: string | null;
    /**
     * Vulnerabilities addressed within this advisory.
     */
    vulnerabilities: Array<AdvisoryVulnerabilityHead>;
  };

export type AdvisoryVulnerabilityHead = VulnerabilityHead & {
  /**
   * The average (arithmetic mean) score this advisory assigns to
   * the particular vulnerability.
   */
  score: number;
  /**
   * The English-language word description of the severity of the given
   * vulnerability, as asserted by the advisory, using the CVSS bucketing
   * ranges.
   *
   * Critical: 9.0–10.0
   * High: 7.0–8.9
   * Medium: 4.0–6.9
   * Low: 0.1–3.9
   * None: 0
   */
  severity: Severity;
};

/**
 * Summary of information from this advisory regarding a single specific vulnerability.
 */
export type AdvisoryVulnerabilitySummary = AdvisoryVulnerabilityHead & {
  /**
   * All CVSS3 scores from the advisory for the given vulnerability.
   * May include several, varying by minor version of the CVSS3 vector.
   */
  cvss3_scores: Array<string>;
};

export type AnalysisStatus = {
  /**
   * The number of graphs loaded in memory
   */
  graph_count: number;
  /**
   * The number of SBOMs found in the database
   */
  sbom_count: number;
};

export type BasePurlDetails = BasePurlHead & {
  versions: Array<VersionedPurlSummary>;
};

export type BasePurlHead = {
  /**
   * The actual base PURL
   */
  purl: Purl;
  /**
   * The ID of the base PURL
   */
  uuid: string;
};

export type BasePurlSummary = BasePurlHead;

export type BaseSummary = {
  cpe: Array<Cpe>;
  document_id: string;
  name: string;
  node_id: string;
  product_name: string;
  product_version: string;
  published: string;
  purl: Array<Purl>;
  sbom_id: string;
  version: string;
};

export type BinaryByteSize = string;

export type ClearlyDefinedCurationImporter = CommonImporter & {
  source?: string;
  types?: Array<ClearlyDefinedPackageType>;
};

export type ClearlyDefinedImporter = CommonImporter & {
  source?: string;
  types?: Array<ClearlyDefinedPackageType>;
};

export type ClearlyDefinedPackageType =
  | "composer"
  | "crate"
  | "deb"
  | "gem"
  | "git"
  | "go"
  | "maven"
  | "npm"
  | "nuget"
  | "pod"
  | "pypi";

export type CommonImporter = {
  /**
   * A description for users.
   */
  description?: string | null;
  /**
   * A flag to disable the importer, without deleting it.
   */
  disabled?: boolean;
  /**
   * Labels which will be applied to the ingested documents.
   */
  labels?: Labels;
  /**
   * The period the importer should be run.
   */
  period: string;
};

export type Cpe = string;

export type CsafImporter = CommonImporter & {
  fetchRetries?: number | null;
  ignoreMissing?: boolean;
  onlyPatterns?: Array<string>;
  source: string;
  v3Signatures?: boolean;
};

export type CveImporter = CommonImporter & {
  source?: string;
  startYear?: number | null;
  years?: Array<number>;
};

export type CweImporter = CommonImporter & {
  source?: string;
};

export type ExternalReferenceQuery = {
  cpe?: null | Cpe;
  purl?: null | Purl;
};

/**
 * A hash/digest prefixed with its type.
 */
export type Id = string;

export type Importer = ImporterData & {
  name: string;
};

export type ImporterConfiguration =
  | {
      sbom: SbomImporter;
    }
  | {
      csaf: CsafImporter;
    }
  | {
      osv: OsvImporter;
    }
  | {
      cve: CveImporter;
    }
  | {
      clearlyDefined: ClearlyDefinedImporter;
    }
  | {
      clearlyDefinedCuration: ClearlyDefinedCurationImporter;
    }
  | {
      cwe: CweImporter;
    };

export type ImporterData = {
  configuration: ImporterConfiguration;
  /**
   * The continuation token of the importer.
   */
  continuation?: unknown;
  /**
   * The last state change
   */
  lastChange: string;
  /**
   * The error of the last run (empty if successful)
   */
  lastError?: string | null;
  /**
   * The last run (successful or not)
   */
  lastRun?: string | null;
  /**
   * The last successful run
   */
  lastSuccess?: string | null;
  /**
   * The current progress.
   */
  progress?: Progress;
  /**
   * The current state of the importer
   */
  state: State;
};

export type ImporterReport = {
  /**
   * The time the report was created
   */
  creation: string;
  /**
   * Errors captured by the report
   */
  error?: string | null;
  /**
   * The ID of the report
   */
  id: string;
  /**
   * The name of the importer this report belongs to
   */
  importer: string;
  report?: null | Report;
};

/**
 * The result of the ingestion process
 */
export type IngestResult = {
  /**
   * The ID declared by the document
   */
  document_id?: string | null;
  /**
   * The internal ID of the document
   */
  id: Id;
  /**
   * Warnings that occurred during the import process
   */
  warnings?: Array<string>;
};

export type Labels = {
  [key: string]: string;
};

export type LicenseSummary = {
  id: string;
  license: string;
  purls: number;
  spdx_license_exceptions: Array<string>;
  spdx_licenses: Array<string>;
};

export type Message = {
  /**
   * The message
   */
  message: string;
  /**
   * The severity of the message
   */
  severity: Severity;
};

export type Node = BaseSummary & {
  /**
   * All ancestors of this node. [`None`] if not requested on this level.
   */
  ancestors?: Array<Node> | null;
  /**
   * All descendents of this node. [`None`] if not requested on this level.
   */
  descendants?: Array<Node> | null;
  relationship?: null | Relationship;
};

export type OrganizationDetails = OrganizationHead & {
  /**
   * Advisories issued by the organization, if any.
   */
  advisories: Array<AdvisoryHead>;
};

/**
 * An organization who may issue advisories, product SBOMs, or
 * otherwise be involved in supply-chain evidence.
 */
export type OrganizationHead = {
  /**
   * The `CPE` key of the organization, if known.
   */
  cpe_key: string | null;
  /**
   * The opaque UUID of the organization.
   */
  id: string;
  /**
   * The name of the organization.
   */
  name: string;
  /**
   * The website of the organization, if known.
   */
  website: string | null;
};

export type OrganizationSummary = OrganizationHead;

export type OsvImporter = CommonImporter & {
  /**
   * An optional branch. Will use the default branch otherwise.
   */
  branch?: string | null;
  /**
   * An optional path to start searching for documents. Will use the root of the repository otherwise.
   */
  path?: string | null;
  /**
   * The URL to the git repository of the OSV data
   */
  source: string;
  startYear?: number | null;
  years?: Array<number>;
};

export type PaginatedResultsAdvisorySummary = {
  items: Array<
    AdvisoryHead &
      (null | SourceDocument) & {
        /**
         * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
         */
        average_score: number | null;
        /**
         * Average (arithmetic mean) severity of the advisory aggregated from *all* related vulnerability assertions.
         */
        average_severity: string | null;
        /**
         * Vulnerabilities addressed within this advisory.
         */
        vulnerabilities: Array<AdvisoryVulnerabilityHead>;
      }
  >;
  total: number;
};

export type PaginatedResultsBasePurlSummary = {
  items: Array<BasePurlHead>;
  total: number;
};

export type PaginatedResultsImporterReport = {
  items: Array<{
    /**
     * The time the report was created
     */
    creation: string;
    /**
     * Errors captured by the report
     */
    error?: string | null;
    /**
     * The ID of the report
     */
    id: string;
    /**
     * The name of the importer this report belongs to
     */
    importer: string;
    report?: null | Report;
  }>;
  total: number;
};

export type PaginatedResultsLicenseSummary = {
  items: Array<{
    id: string;
    license: string;
    purls: number;
    spdx_license_exceptions: Array<string>;
    spdx_licenses: Array<string>;
  }>;
  total: number;
};

export type PaginatedResultsNode = {
  items: Array<
    BaseSummary & {
      /**
       * All ancestors of this node. [`None`] if not requested on this level.
       */
      ancestors?: Array<Node> | null;
      /**
       * All descendents of this node. [`None`] if not requested on this level.
       */
      descendants?: Array<Node> | null;
      relationship?: null | Relationship;
    }
  >;
  total: number;
};

export type PaginatedResultsProductSummary = {
  items: Array<
    ProductHead & {
      vendor: null | OrganizationSummary;
      versions: Array<ProductVersionHead>;
    }
  >;
  total: number;
};

export type PaginatedResultsPurlSummary = {
  items: Array<
    PurlHead & {
      base: BasePurlHead;
      qualifiers: {
        [key: string]: string;
      };
      version: VersionedPurlHead;
    }
  >;
  total: number;
};

export type PaginatedResultsSbomPackage = {
  items: Array<{
    cpe: Array<string>;
    id: string;
    name: string;
    purl: Array<PurlSummary>;
    version?: string | null;
  }>;
  total: number;
};

export type PaginatedResultsSbomPackageRelation = {
  items: Array<{
    package: SbomPackage;
    relationship: Relationship;
  }>;
  total: number;
};

export type PaginatedResultsSbomSummary = {
  items: Array<
    SbomHead &
      (null | SourceDocument) & {
        described_by: Array<SbomPackage>;
      }
  >;
  total: number;
};

export type PaginatedResultsSpdxLicenseSummary = {
  items: Array<{
    id: string;
    name: string;
  }>;
  total: number;
};

export type PaginatedResultsVulnerabilitySummary = {
  items: Array<
    VulnerabilityHead & {
      advisories: Array<VulnerabilityAdvisoryHead>;
      /**
       * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
       */
      average_score: number | null;
      average_severity: null | Severity;
    }
  >;
  total: number;
};

export type ProductDetails = ProductHead & {
  vendor: null | OrganizationSummary;
  versions: Array<ProductVersionDetails>;
};

export type ProductHead = {
  id: string;
  name: string;
};

export type ProductSbomHead = {
  labels: Labels;
  published: string | null;
};

export type ProductSummary = ProductHead & {
  vendor: null | OrganizationSummary;
  versions: Array<ProductVersionHead>;
};

export type ProductVersionDetails = ProductVersionHead & {
  sbom?: null | ProductSbomHead;
};

export type ProductVersionHead = {
  id: string;
  sbom_id?: string;
  version: string;
};

export type Progress = (null | ProgressDetails) & {
  message?: string | null;
};

export type ProgressDetails = {
  /**
   * The current processed items.
   */
  current: number;
  /**
   * The estimated time of completion.
   */
  estimatedCompletion: string;
  /**
   * The estimated remaining time in seconds.
   */
  estimatedSecondsRemaining: number;
  /**
   * Progress in percent (0..=1)
   */
  percent: number;
  /**
   * The average processing rate (per second).
   */
  rate: number;
  /**
   * The total number of items to be processed.
   */
  total: number;
};

export type Purl = string;

export type PurlAdvisory = AdvisoryHead & {
  status: Array<PurlStatus>;
};

export type PurlDetails = PurlHead & {
  advisories: Array<PurlAdvisory>;
  base: BasePurlHead;
  licenses: Array<PurlLicenseSummary>;
  version: VersionedPurlHead;
};

export type PurlHead = {
  /**
   * The actual qualified PURL
   */
  purl: Purl;
  /**
   * The ID of the qualified PURL
   */
  uuid: string;
};

export type PurlLicenseSummary = {
  licenses: Array<string>;
  sbom: SbomHead;
};

export type PurlStatus = {
  average_severity: Severity;
  context: null | StatusContext;
  status: string;
  vulnerability: VulnerabilityHead;
};

export type PurlSummary = PurlHead & {
  base: BasePurlHead;
  qualifiers: {
    [key: string]: string;
  };
  version: VersionedPurlHead;
};

export type Relationship =
  | "contains"
  | "dependency"
  | "dev_dependency"
  | "optional_dependency"
  | "provided_dependency"
  | "test_dependency"
  | "runtime_dependency"
  | "example"
  | "generates"
  | "ancestor_of"
  | "variant"
  | "build_tool"
  | "dev_tool"
  | "describes"
  | "package"
  | "undefined";

export type Report = {
  /**
   * End of the import run
   */
  endDate: string;
  /**
   * Messages emitted during processing
   */
  messages?: {
    [key: string]: {
      [key: string]: Array<Message>;
    };
  };
  /**
   * Number of processes items
   */
  numberOfItems?: number;
  /**
   * Start of the import run
   */
  startDate: string;
};

/**
 * A struct wrapping an item with a revision.
 *
 * If the revision should not be part of the payload, but e.g. an HTTP header (like `ETag`), this
 * struct can help carrying both pieces.
 */
export type RevisionedImporter = {
  /**
   * The revision.
   *
   * An opaque string that should have no meaning to the user, only to the backend.
   */
  revision: string;
  value: ImporterData & {
    name: string;
  };
};

export type SbomAdvisory = AdvisoryHead & {
  status: Array<SbomStatus>;
};

export type SbomHead = {
  authors: Array<string>;
  data_licenses: Array<string>;
  document_id?: string | null;
  id: string;
  labels: Labels;
  name: string;
  /**
   * The number of packages this SBOM has
   */
  number_of_packages: number;
  published: string | null;
};

export type SbomImporter = CommonImporter & {
  fetchRetries?: number | null;
  ignoreMissing?: boolean;
  keys?: Array<string>;
  onlyPatterns?: Array<string>;
  sizeLimit?: null | BinaryByteSize;
  source: string;
  v3Signatures?: boolean;
};

export type SbomPackage = {
  cpe: Array<string>;
  id: string;
  name: string;
  purl: Array<PurlSummary>;
  version?: string | null;
};

export type SbomPackageRelation = {
  package: SbomPackage;
  relationship: Relationship;
};

export type SbomStatus = VulnerabilityHead & {
  average_severity: Severity;
  context?: null | StatusContext;
  packages: Array<SbomPackage>;
  status: string;
};

export type SbomSummary = SbomHead &
  (null | SourceDocument) & {
    described_by: Array<SbomPackage>;
  };

/**
 * Qualitative Severity Rating Scale
 *
 * Described in CVSS v3.1 Specification: Section 5:
 * <https://www.first.org/cvss/specification-document#t17>
 *
 * > For some purposes it is useful to have a textual representation of the
 * > numeric Base, Temporal and Environmental scores.
 */
export type Severity = "none" | "low" | "medium" | "high" | "critical";

export type SourceDocument = {
  /**
   * The timestamp the document was ingested
   */
  ingested: string;
  sha256: string;
  sha384: string;
  sha512: string;
  size: number;
};

export type SpdxLicenseDetails = SpdxLicenseSummary & {
  text: string;
};

export type SpdxLicenseSummary = {
  id: string;
  name: string;
};

export type State = "waiting" | "running";

export type StatusContext =
  | {
      purl: Purl;
    }
  | {
      cpe: string;
    };

export type TypeCounts = {
  base: number;
  package: number;
  version: number;
};

export type TypeHead = {
  name: string;
};

export type TypeSummary = TypeHead & {
  counts: TypeCounts;
};

export type VersionedPurlAdvisory = AdvisoryHead & {
  status: Array<VersionedPurlStatus>;
};

export type VersionedPurlDetails = VersionedPurlHead & {
  advisories: Array<VersionedPurlAdvisory>;
  base: BasePurlHead;
  purls: Array<PurlHead>;
};

export type VersionedPurlHead = {
  /**
   * The actual, versioned PURL
   */
  purl: Purl;
  /**
   * The ID of the versioned PURL
   */
  uuid: string;
  /**
   * The version from the PURL
   */
  version: string;
};

export type VersionedPurlStatus = {
  status: string;
  vulnerability: VulnerabilityHead;
};

export type VersionedPurlSummary = VersionedPurlHead & {
  base: BasePurlHead;
  purls: Array<PurlHead>;
};

export type VulnerabilityAdvisoryHead = AdvisoryHead & {
  score: number | null;
  severity: null | Severity;
};

export type VulnerabilityAdvisoryStatus = {
  base_purl: BasePurlHead;
  context: null | StatusContext;
  version: string;
};

export type VulnerabilityAdvisorySummary = VulnerabilityAdvisoryHead & {
  /**
   * CVSS3 scores from this advisory regarding the vulnerability.
   */
  cvss3_scores: Array<string>;
  /**
   * The total number of vulnerabilities described by this advisory
   */
  number_of_vulnerabilities: number;
  purls: {
    [key: string]: Array<VulnerabilityAdvisoryStatus>;
  };
  /**
   * SBOMs claimed by this advisory to be addressed by this vulnerability.
   */
  sboms: Array<VulnerabilitySbomStatus>;
};

export type VulnerabilityDetails = VulnerabilityHead & {
  /**
   * Advisories addressing this vulnerability, if any.
   */
  advisories: Array<VulnerabilityAdvisorySummary>;
  /**
   * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
   */
  average_score: number | null;
  average_severity: null | Severity;
};

export type VulnerabilityHead = {
  /**
   * Associated CWE, if any.
   */
  cwes: Array<string>;
  /**
   * The description of the vulnerability, if known.
   */
  description: string | null;
  /**
   * The date (in RFC3339 format) of when the vulnerability was discovered, if any.
   */
  discovered: string | null;
  /**
   * The globally-unique identifier for the vulnerability.
   * Traditionally (but not required) refers to the assigned
   * CVE identifier.
   */
  identifier: string;
  /**
   * The date (in RFC3339 format) of when the vulnerability was last modified, if any.
   */
  modified: string | null;
  normative: boolean;
  /**
   * The date (in RFC3339 format) of when the vulnerability was published, if any.
   */
  published: string | null;
  /**
   * The date (in RFC3339 format) of when software containing the vulnerability first released, if known.
   */
  released: string | null;
  /**
   * The date (in RFC3339 format) of when the vulnerability identifier was reserved, if any.
   */
  reserved: string | null;
  /**
   * The title of the vulnerability, if known.
   */
  title: string | null;
  /**
   * The date (in RFC3339 format) of when the vulnerability was last withdrawn, if any.
   */
  withdrawn: string | null;
};

export type VulnerabilitySbomStatus = SbomHead & {
  purl_statuses: {
    [key: string]: Array<PurlSummary>;
  };
  version?: string | null;
};

export type VulnerabilitySummary = VulnerabilityHead & {
  advisories: Array<VulnerabilityAdvisoryHead>;
  /**
   * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
   */
  average_score: number | null;
  average_severity: null | Severity;
};

export type InfoData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/.well-known/trustify";
};

export type InfoResponses = {
  /**
   * Get information
   */
  200: {
    build?: {
      [key: string]: unknown;
    };
    version: string;
  };
};

export type InfoResponse = InfoResponses[keyof InfoResponses];

export type ListAdvisoriesData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
    deprecated?: "Ignore" | "Consider";
  };
  url: "/api/v2/advisory";
};

export type ListAdvisoriesResponses = {
  /**
   * Matching vulnerabilities
   */
  200: PaginatedResultsAdvisorySummary;
};

export type ListAdvisoriesResponse =
  ListAdvisoriesResponses[keyof ListAdvisoriesResponses];

export type UploadAdvisoryData = {
  body: Blob | File;
  path?: never;
  query: {
    /**
     * Optional issuer if it cannot be determined from advisory contents.
     */
    issuer?: string | null;
    /**
     * Optional labels.
     *
     * Only use keys with a prefix of `labels.`
     */
    labels: Labels;
  };
  url: "/api/v2/advisory";
};

export type UploadAdvisoryErrors = {
  /**
   * The file could not be parsed as an advisory
   */
  400: unknown;
};

export type UploadAdvisoryResponses = {
  /**
   * Upload a file
   */
  201: unknown;
};

export type PatchAdvisoryLabelsData = {
  body: Labels;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: Id;
  };
  query?: never;
  url: "/api/v2/advisory/{id}/label";
};

export type PatchAdvisoryLabelsErrors = {
  /**
   * The advisory could not be found
   */
  404: unknown;
};

export type PatchAdvisoryLabelsResponses = {
  /**
   * Modified the labels of the advisory
   */
  204: void;
};

export type PatchAdvisoryLabelsResponse =
  PatchAdvisoryLabelsResponses[keyof PatchAdvisoryLabelsResponses];

export type UpdateAdvisoryLabelsData = {
  body: Labels;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: Id;
  };
  query?: never;
  url: "/api/v2/advisory/{id}/label";
};

export type UpdateAdvisoryLabelsErrors = {
  /**
   * The advisory could not be found
   */
  404: unknown;
};

export type UpdateAdvisoryLabelsResponses = {
  /**
   * Replaced the labels of the advisory
   */
  204: void;
};

export type UpdateAdvisoryLabelsResponse =
  UpdateAdvisoryLabelsResponses[keyof UpdateAdvisoryLabelsResponses];

export type DeleteAdvisoryData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/advisory/{key}";
};

export type DeleteAdvisoryErrors = {
  /**
   * Matching advisory not found
   */
  404: unknown;
};

export type DeleteAdvisoryResponses = {
  /**
   * Matching advisory
   */
  200: AdvisoryDetails;
};

export type DeleteAdvisoryResponse =
  DeleteAdvisoryResponses[keyof DeleteAdvisoryResponses];

export type GetAdvisoryData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/advisory/{key}";
};

export type GetAdvisoryErrors = {
  /**
   * Matching advisory not found
   */
  404: unknown;
};

export type GetAdvisoryResponses = {
  /**
   * Matching advisory
   */
  200: AdvisoryDetails;
};

export type GetAdvisoryResponse =
  GetAdvisoryResponses[keyof GetAdvisoryResponses];

export type DownloadAdvisoryData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>'
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/advisory/{key}/download";
};

export type DownloadAdvisoryErrors = {
  /**
   * The document could not be found
   */
  404: unknown;
};

export type DownloadAdvisoryResponses = {
  /**
   * Download a an advisory
   */
  200: Blob | File;
};

export type DownloadAdvisoryResponse =
  DownloadAdvisoryResponses[keyof DownloadAdvisoryResponses];

export type SearchComponentData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
    /**
     * The level of ancestors to return.
     *
     * Zero, the default, meaning none.
     */
    ancestors?: number;
    /**
     * The level of descendants to return.
     *
     * Zero, the default, meaning none.
     */
    descendants?: number;
    /**
     * A set of relationships to filter for, deserialized from a
     * comma-delimited string
     *
     * An empty set, the default, meaning all relationships.
     */
    relationships?: string;
  };
  url: "/api/v2/analysis/component";
};

export type SearchComponentErrors = {
  /**
   * The user did not provide valid authentication credentials
   */
  401: unknown;
  /**
   * The user lacks the required permission
   */
  403: unknown;
};

export type SearchComponentResponses = {
  /**
   * Retrieved component(s) located by search
   */
  200: PaginatedResultsNode;
};

export type SearchComponentResponse =
  SearchComponentResponses[keyof SearchComponentResponses];

export type GetComponentData = {
  body?: never;
  path: {
    /**
     * provide component name, URL-encoded pURL, or CPE itself
     */
    key: string;
    q: string;
    sort: string;
  };
  query?: {
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
    /**
     * The level of ancestors to return.
     *
     * Zero, the default, meaning none.
     */
    ancestors?: number;
    /**
     * The level of descendants to return.
     *
     * Zero, the default, meaning none.
     */
    descendants?: number;
    /**
     * A set of relationships to filter for, deserialized from a
     * comma-delimited string
     *
     * An empty set, the default, meaning all relationships.
     */
    relationships?: string;
  };
  url: "/api/v2/analysis/component/{key}";
};

export type GetComponentErrors = {
  /**
   * The user did not provide valid authentication credentials
   */
  401: unknown;
  /**
   * The user lacks the required permission
   */
  403: unknown;
};

export type GetComponentResponses = {
  /**
   * Retrieved component(s) located by name, pURL, or CPE
   */
  200: PaginatedResultsNode;
};

export type GetComponentResponse =
  GetComponentResponses[keyof GetComponentResponses];

export type RenderSbomGraphData = {
  body?: never;
  path: {
    /**
     * ID of the SBOM
     */
    sbom: string;
    /**
     * Renderer to use
     */
    ext: "gv";
  };
  query?: never;
  url: "/api/v2/analysis/sbom/{sbom}/render.{ext}";
};

export type RenderSbomGraphErrors = {
  /**
   * The user did not provide valid authentication credentials
   */
  401: unknown;
  /**
   * The user lacks the required permission
   */
  403: unknown;
  /**
   * The SBOM was not found
   */
  404: unknown;
  /**
   * Unsupported rendering format
   */
  415: unknown;
};

export type RenderSbomGraphResponses = {
  /**
   * A rendered version of the SBOM graph in the format requested
   */
  200: string;
};

export type RenderSbomGraphResponse =
  RenderSbomGraphResponses[keyof RenderSbomGraphResponses];

export type StatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v2/analysis/status";
};

export type StatusErrors = {
  /**
   * The user did not provide valid authentication credentials
   */
  401: unknown;
  /**
   * The user lacks the required permission
   */
  403: unknown;
};

export type StatusResponses = {
  /**
   * Analysis status
   */
  200: AnalysisStatus;
};

export type StatusResponse = StatusResponses[keyof StatusResponses];

export type UploadDatasetData = {
  body: Blob | File;
  path?: never;
  query: {
    /**
     * Optional labels.
     *
     * Only use keys with a prefix of `labels.`
     */
    labels: Labels;
  };
  url: "/api/v2/dataset";
};

export type UploadDatasetErrors = {
  /**
   * The file could not be parsed as an dataset
   */
  400: unknown;
};

export type UploadDatasetResponses = {
  /**
   * Uploaded the dataset
   */
  201: unknown;
};

export type ListImportersData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v2/importer";
};

export type ListImportersResponses = {
  /**
   * List importer configurations
   */
  200: Array<Importer>;
};

export type ListImportersResponse =
  ListImportersResponses[keyof ListImportersResponses];

export type DeleteImporterData = {
  body?: never;
  headers?: {
    /**
     * The revision to delete
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}";
};

export type DeleteImporterResponses = {
  /**
   * Delete the importer configuration
   */
  201: unknown;
};

export type GetImporterData = {
  body?: never;
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}";
};

export type GetImporterErrors = {
  /**
   * An importer with that name could not be found
   */
  404: unknown;
};

export type GetImporterResponses = {
  /**
   * Retrieved importer configuration
   */
  200: RevisionedImporter;
};

export type GetImporterResponse =
  GetImporterResponses[keyof GetImporterResponses];

export type PatchImporterData = {
  body: unknown;
  headers?: {
    /**
     * The revision to update
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}";
};

export type PatchImporterErrors = {
  /**
   * An importer with that name does not exist
   */
  409: unknown;
  /**
   * The provided if-match header did not match the stored revision
   */
  412: unknown;
};

export type PatchImporterResponses = {
  /**
   * Created a new importer configuration
   */
  201: unknown;
};

export type CreateImporterData = {
  body: ImporterConfiguration;
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}";
};

export type CreateImporterErrors = {
  /**
   * An importer with that name already exists
   */
  409: unknown;
};

export type CreateImporterResponses = {
  /**
   * Created a new importer configuration
   */
  201: unknown;
};

export type UpdateImporterData = {
  body: ImporterConfiguration;
  headers?: {
    /**
     * The revision to update
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}";
};

export type UpdateImporterErrors = {
  /**
   * An importer with that name does not exist
   */
  409: unknown;
  /**
   * The provided if-match header did not match the stored revision
   */
  412: unknown;
};

export type UpdateImporterResponses = {
  /**
   * Updated the importer configuration
   */
  201: unknown;
};

export type EnableImporterData = {
  body: boolean;
  headers?: {
    /**
     * The revision to update
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}/enabled";
};

export type EnableImporterErrors = {
  /**
   * An importer with that name does not exist
   */
  404: unknown;
  /**
   * The provided if-match header did not match the stored revision
   */
  412: unknown;
};

export type EnableImporterResponses = {
  /**
   * Updated the enable state
   */
  201: unknown;
};

export type ForceRunImporterData = {
  body: boolean;
  headers?: {
    /**
     * The revision to update
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The name of the importer
     */
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}/force";
};

export type ForceRunImporterErrors = {
  /**
   * An importer with that name does not exist
   */
  404: unknown;
  /**
   * The provided if-match header did not match the stored revision
   */
  412: unknown;
};

export type ForceRunImporterResponses = {
  /**
   * Updated the state
   */
  201: unknown;
};

export type ListImporterReportsData = {
  body?: never;
  path: {
    name: string;
  };
  query?: never;
  url: "/api/v2/importer/{name}/report";
};

export type ListImporterReportsResponses = {
  /**
   * Retrieved importer reports
   */
  200: PaginatedResultsImporterReport;
};

export type ListImporterReportsResponse =
  ListImporterReportsResponses[keyof ListImporterReportsResponses];

export type ListLicensesData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/license";
};

export type ListLicensesResponses = {
  /**
   * Matching licenses
   */
  200: PaginatedResultsLicenseSummary;
};

export type ListLicensesResponse =
  ListLicensesResponses[keyof ListLicensesResponses];

export type ListSpdxLicensesData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/license/spdx/license";
};

export type ListSpdxLicensesResponses = {
  /**
   * Matching licenses
   */
  200: PaginatedResultsSpdxLicenseSummary;
};

export type ListSpdxLicensesResponse =
  ListSpdxLicensesResponses[keyof ListSpdxLicensesResponses];

export type GetSpdxLicenseData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/api/v2/license/spdx/license/{id}";
};

export type GetSpdxLicenseResponses = {
  /**
   * SPDX license details
   */
  200: SpdxLicenseDetails;
};

export type GetSpdxLicenseResponse =
  GetSpdxLicenseResponses[keyof GetSpdxLicenseResponses];

export type GetLicensesData = {
  body?: never;
  path: {
    uuid: string;
  };
  query?: never;
  url: "/api/v2/license/{uuid}";
};

export type GetLicensesResponses = {
  /**
   * The license
   */
  200: LicenseSummary;
};

export type GetLicensesResponse =
  GetLicensesResponses[keyof GetLicensesResponses];

export type GetLicensePurlsData = {
  body?: never;
  path: {
    uuid: string;
  };
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/license/{uuid}/purl";
};

export type GetLicensePurlsResponses = {
  /**
   * The versioned pURLs allowing the license
   */
  200: LicenseSummary;
};

export type GetLicensePurlsResponse =
  GetLicensePurlsResponses[keyof GetLicensePurlsResponses];

export type ListOrganizationsData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/organization";
};

export type ListOrganizationsResponses = {
  /**
   * Matching organizations
   */
  200: OrganizationSummary;
};

export type ListOrganizationsResponse =
  ListOrganizationsResponses[keyof ListOrganizationsResponses];

export type GetOrganizationData = {
  body?: never;
  path: {
    /**
     * Opaque ID of the organization
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/organization/{id}";
};

export type GetOrganizationErrors = {
  /**
   * Matching organization not found
   */
  404: unknown;
};

export type GetOrganizationResponses = {
  /**
   * Matching organization
   */
  200: OrganizationDetails;
};

export type GetOrganizationResponse =
  GetOrganizationResponses[keyof GetOrganizationResponses];

export type ListProductsData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/product";
};

export type ListProductsResponses = {
  /**
   * Matching products
   */
  200: PaginatedResultsProductSummary;
};

export type ListProductsResponse =
  ListProductsResponses[keyof ListProductsResponses];

export type DeleteProductData = {
  body?: never;
  path: {
    /**
     * Opaque ID of the product
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/product/{id}";
};

export type DeleteProductErrors = {
  /**
   * Matching product not found
   */
  404: unknown;
};

export type DeleteProductResponses = {
  /**
   * Matching product
   */
  200: ProductDetails;
};

export type DeleteProductResponse =
  DeleteProductResponses[keyof DeleteProductResponses];

export type GetProductData = {
  body?: never;
  path: {
    /**
     * Opaque ID of the product
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/product/{id}";
};

export type GetProductErrors = {
  /**
   * Matching product not found
   */
  404: unknown;
};

export type GetProductResponses = {
  /**
   * Matching product
   */
  200: ProductDetails;
};

export type GetProductResponse = GetProductResponses[keyof GetProductResponses];

export type ListPurlData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/purl";
};

export type ListPurlResponses = {
  /**
   * All relevant matching qualified PURLs
   */
  200: PaginatedResultsPurlSummary;
};

export type ListPurlResponse = ListPurlResponses[keyof ListPurlResponses];

export type ListBasePurlsData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/purl/base";
};

export type ListBasePurlsResponses = {
  /**
   * All relevant matching versionless base PURL
   */
  200: PaginatedResultsBasePurlSummary;
};

export type ListBasePurlsResponse =
  ListBasePurlsResponses[keyof ListBasePurlsResponses];

export type GetBasePurlData = {
  body?: never;
  path: {
    /**
     * opaque identifier for a base PURL, or a URL-encoded pURL itself
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/purl/base/{key}";
};

export type GetBasePurlResponses = {
  /**
   * Details for the versionless base PURL
   */
  200: BasePurlDetails;
};

export type GetBasePurlResponse =
  GetBasePurlResponses[keyof GetBasePurlResponses];

export type ListPurlTypesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v2/purl/type";
};

export type ListPurlTypesResponses = {
  /**
   * List of all known PURL types
   */
  200: Array<TypeSummary>;
};

export type ListPurlTypesResponse =
  ListPurlTypesResponses[keyof ListPurlTypesResponses];

export type GetPurlTypeData = {
  body?: never;
  path: {
    /**
     * PURL identifier of a type
     */
    type: string;
  };
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/purl/type/{type}";
};

export type GetPurlTypeResponses = {
  /**
   * Information regarding PURLs within an type
   */
  200: PaginatedResultsBasePurlSummary;
};

export type GetPurlTypeResponse =
  GetPurlTypeResponses[keyof GetPurlTypeResponses];

export type GetBasePurlOfTypeData = {
  body?: never;
  path: {
    /**
     * PURL identifier of a type
     */
    type: string;
    /**
     * name of the package optionally preceded by its namespace
     */
    namespace_and_name: string;
  };
  query?: never;
  url: "/api/v2/purl/type/{type}/{namespace_and_name}";
};

export type GetBasePurlOfTypeResponses = {
  /**
   * Matching vulnerabilities
   */
  200: BasePurlDetails;
};

export type GetBasePurlOfTypeResponse =
  GetBasePurlOfTypeResponses[keyof GetBasePurlOfTypeResponses];

export type GetVersionedPurlOfTypeData = {
  body?: never;
  path: {
    /**
     * PURL identifier of a type
     */
    type: string;
    /**
     * name of the package optionally preceded by its namespace
     */
    namespace_and_name: string;
    /**
     * version of the package
     */
    version: string;
  };
  query?: never;
  url: "/api/v2/purl/type/{type}/{namespace_and_name}@{version}";
};

export type GetVersionedPurlOfTypeResponses = {
  /**
   * Matching vulnerabilities
   */
  200: VersionedPurlDetails;
};

export type GetVersionedPurlOfTypeResponse =
  GetVersionedPurlOfTypeResponses[keyof GetVersionedPurlOfTypeResponses];

export type GetVersionedPurlData = {
  body?: never;
  path: {
    /**
     * opaque ID identifier for a package version, or URL-ecnoded pURL itself
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/purl/version/{key}";
};

export type GetVersionedPurlResponses = {
  /**
   * Details for the version of a PURL
   */
  200: VersionedPurlDetails;
};

export type GetVersionedPurlResponse =
  GetVersionedPurlResponses[keyof GetVersionedPurlResponses];

export type GetPurlData = {
  body?: never;
  path: {
    /**
     * opaque identifier for a fully-qualified PURL, or URL-encoded pURL itself
     */
    key: string;
  };
  query?: {
    deprecated?: "Ignore" | "Consider";
  };
  url: "/api/v2/purl/{key}";
};

export type GetPurlResponses = {
  /**
   * Details for the qualified PURL
   */
  200: PurlDetails;
};

export type GetPurlResponse = GetPurlResponses[keyof GetPurlResponses];

export type ListSbomsData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/sbom";
};

export type ListSbomsResponses = {
  /**
   * Matching SBOMs
   */
  200: PaginatedResultsSbomSummary;
};

export type ListSbomsResponse = ListSbomsResponses[keyof ListSbomsResponses];

export type UploadSbomData = {
  body: Array<number>;
  path?: never;
  query: {
    /**
     * Optional labels.
     *
     * Only use keys with a prefix of `labels.`
     */
    labels: Labels;
    /**
     * Source the document came from
     */
    location: string;
  };
  url: "/api/v2/sbom";
};

export type UploadSbomErrors = {
  /**
   * The file could not be parsed as an advisory
   */
  400: unknown;
};

export type UploadSbomResponses = {
  /**
   * Upload an SBOM
   */
  201: IngestResult;
};

export type UploadSbomResponse = UploadSbomResponses[keyof UploadSbomResponses];

export type ListRelatedSbomsData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
    /**
     * Find by PURL
     */
    purl?: null | Purl;
    /**
     * Find by CPE
     */
    cpe?: null | Cpe;
  };
  url: "/api/v2/sbom/by-package";
};

export type ListRelatedSbomsResponses = {
  /**
   * Matching SBOMs
   */
  200: PaginatedResultsSbomSummary;
};

export type ListRelatedSbomsResponse =
  ListRelatedSbomsResponses[keyof ListRelatedSbomsResponses];

export type CountRelatedSbomsData = {
  body: Array<ExternalReferenceQuery>;
  path: {
    /**
     * Find by PURL
     */
    purl: null | Purl;
    /**
     * Find by CPE
     */
    cpe: null | Cpe;
  };
  query?: never;
  url: "/api/v2/sbom/count-by-package";
};

export type CountRelatedSbomsResponses = {
  /**
   * Number of matching SBOMs per package
   */
  200: Array<number>;
};

export type CountRelatedSbomsResponse =
  CountRelatedSbomsResponses[keyof CountRelatedSbomsResponses];

export type DeleteSbomData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/sbom/{id}";
};

export type DeleteSbomErrors = {
  /**
   * Matching SBOM not found
   */
  404: unknown;
};

export type DeleteSbomResponses = {
  /**
   * Matching SBOM
   */
  200: SbomSummary;
};

export type DeleteSbomResponse = DeleteSbomResponses[keyof DeleteSbomResponses];

export type GetSbomData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/sbom/{id}";
};

export type GetSbomErrors = {
  /**
   * Matching SBOM not found
   */
  404: unknown;
};

export type GetSbomResponses = {
  /**
   * Matching SBOM
   */
  200: SbomSummary;
};

export type GetSbomResponse = GetSbomResponses[keyof GetSbomResponses];

export type GetSbomAdvisoriesData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/sbom/{id}/advisory";
};

export type GetSbomAdvisoriesErrors = {
  /**
   * Matching SBOM not found
   */
  404: unknown;
};

export type GetSbomAdvisoriesResponses = {
  /**
   * Matching SBOM
   */
  200: Array<SbomAdvisory>;
};

export type GetSbomAdvisoriesResponse =
  GetSbomAdvisoriesResponses[keyof GetSbomAdvisoriesResponses];

export type PatchSbomLabelsData = {
  body: Labels;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: Id;
  };
  query?: never;
  url: "/api/v2/sbom/{id}/label";
};

export type PatchSbomLabelsErrors = {
  /**
   * The SBOM could not be found
   */
  404: unknown;
};

export type PatchSbomLabelsResponses = {
  /**
   * Modified the labels of the SBOM
   */
  204: void;
};

export type PatchSbomLabelsResponse =
  PatchSbomLabelsResponses[keyof PatchSbomLabelsResponses];

export type UpdateSbomLabelsData = {
  body: Labels;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
     */
    id: Id;
  };
  query?: never;
  url: "/api/v2/sbom/{id}/label";
};

export type UpdateSbomLabelsErrors = {
  /**
   * The SBOM could not be found
   */
  404: unknown;
};

export type UpdateSbomLabelsResponses = {
  /**
   * Replaced the labels of the SBOM
   */
  204: void;
};

export type UpdateSbomLabelsResponse =
  UpdateSbomLabelsResponses[keyof UpdateSbomLabelsResponses];

export type ListPackagesData = {
  body?: never;
  path: {
    /**
     * ID of the SBOM to get packages for
     */
    id: string;
  };
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/sbom/{id}/packages";
};

export type ListPackagesResponses = {
  /**
   * Packages
   */
  200: PaginatedResultsSbomPackage;
};

export type ListPackagesResponse =
  ListPackagesResponses[keyof ListPackagesResponses];

export type ListRelatedPackagesData = {
  body?: never;
  path: {
    /**
     * ID of SBOM to search packages in
     */
    id: string;
  };
  query?: {
    /**
     * The Package to use as reference
     */
    reference?: string | null;
    /**
     * Which side the reference should be on
     */
    which?: "left" | "right";
    /**
     * Optional relationship filter
     */
    relationship?: null | Relationship;
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/sbom/{id}/related";
};

export type ListRelatedPackagesResponses = {
  /**
   * Packages
   */
  200: PaginatedResultsSbomPackageRelation;
};

export type ListRelatedPackagesResponse =
  ListRelatedPackagesResponses[keyof ListRelatedPackagesResponses];

export type DownloadSbomData = {
  body?: never;
  path: {
    /**
     * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>'
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/sbom/{key}/download";
};

export type DownloadSbomErrors = {
  /**
   * The document could not be found
   */
  404: unknown;
};

export type DownloadSbomResponses = {
  /**
   * Download a an SBOM
   */
  200: Blob | File;
};

export type DownloadSbomResponse =
  DownloadSbomResponses[keyof DownloadSbomResponses];

export type DeleteUserPreferencesData = {
  body: unknown;
  headers?: {
    /**
     * The revision to delete
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The key to the user preferences
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/userPreference/{key}";
};

export type DeleteUserPreferencesErrors = {
  /**
   * The provided If-Match revision did not match the actual revision
   */
  412: unknown;
};

export type DeleteUserPreferencesResponses = {
  /**
   * User preferences are deleted
   */
  201: unknown;
};

export type GetUserPreferencesData = {
  body?: never;
  path: {
    /**
     * The key to the user preferences
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/userPreference/{key}";
};

export type GetUserPreferencesErrors = {
  /**
   * Unknown user preference key
   */
  404: unknown;
};

export type GetUserPreferencesResponses = {
  /**
   * User preference stored under this key
   */
  200: unknown;
};

export type SetUserPreferencesData = {
  body: unknown;
  headers?: {
    /**
     * The revision to update
     */
    "if-match"?: string | null;
  };
  path: {
    /**
     * The key to the user preferences
     */
    key: string;
  };
  query?: never;
  url: "/api/v2/userPreference/{key}";
};

export type SetUserPreferencesErrors = {
  /**
   * The provided If-Match revision did not match the actual revision
   */
  412: unknown;
};

export type SetUserPreferencesResponses = {
  /**
   * User preference stored under this key
   */
  200: unknown;
};

export type ListVulnerabilitiesData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/vulnerability";
};

export type ListVulnerabilitiesResponses = {
  /**
   * Matching vulnerabilities
   */
  200: PaginatedResultsVulnerabilitySummary;
};

export type ListVulnerabilitiesResponse =
  ListVulnerabilitiesResponses[keyof ListVulnerabilitiesResponses];

export type DeleteVulnerabilityData = {
  body?: never;
  path: {
    /**
     * ID of the vulnerability
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/vulnerability/{id}";
};

export type DeleteVulnerabilityErrors = {
  /**
   * Specified vulnerability not found
   */
  404: unknown;
};

export type DeleteVulnerabilityResponses = {
  /**
   * Specified vulnerability
   */
  200: VulnerabilityDetails;
};

export type DeleteVulnerabilityResponse =
  DeleteVulnerabilityResponses[keyof DeleteVulnerabilityResponses];

export type GetVulnerabilityData = {
  body?: never;
  path: {
    /**
     * ID of the vulnerability
     */
    id: string;
  };
  query?: never;
  url: "/api/v2/vulnerability/{id}";
};

export type GetVulnerabilityErrors = {
  /**
   * Specified vulnerability not found
   */
  404: unknown;
};

export type GetVulnerabilityResponses = {
  /**
   * Specified vulnerability
   */
  200: VulnerabilityDetails;
};

export type GetVulnerabilityResponse =
  GetVulnerabilityResponses[keyof GetVulnerabilityResponses];

export type ListWeaknessesData = {
  body?: never;
  path?: never;
  query?: {
    q?: string;
    sort?: string;
    /**
     * The first item to return, skipping all that come before it.
     *
     * NOTE: The order of items is defined by the API being called.
     */
    offset?: number;
    /**
     * The maximum number of entries to return.
     *
     * Zero means: no limit
     */
    limit?: number;
  };
  url: "/api/v2/weakness";
};

export type ListWeaknessesResponses = {
  /**
   * Matching weaknesses
   */
  200: PaginatedResultsLicenseSummary;
};

export type ListWeaknessesResponse =
  ListWeaknessesResponses[keyof ListWeaknessesResponses];

export type GetWeaknessData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/api/v2/weakness/{id}";
};

export type GetWeaknessResponses = {
  /**
   * The weakness
   */
  200: LicenseSummary;
};

export type GetWeaknessResponse =
  GetWeaknessResponses[keyof GetWeaknessResponses];

export type ClientOptions = {
  baseURL: `${string}://config` | (string & {});
};
